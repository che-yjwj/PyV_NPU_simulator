import pytest
from pyv_npu.config import SimConfig
from pyv_npu.isa.npu_ir import Program, NPUOp, Tensor
from pyv_npu.runtime.scheduler import event_driven_schedule

def test_scheduler_stall_reason_dep():
    """Tests that dependency stalls are correctly identified."""
    # op1 -> op2. op2 must wait for op1.
    t_in1 = Tensor("t_in1", (1,1), "float16", address=0)
    t_in2 = Tensor("t_in2", (1,1), "float16", address=100)
    t_out1 = Tensor("t_out1", (1,1), "float16", address=200)
    
    op1 = NPUOp("MatMul", "op1", inputs=[t_in1, t_in2], outputs=[t_out1])
    op2 = NPUOp("GELU", "op2", inputs=[t_out1], outputs=[])
    # The program's inputs are the tensors that are not generated by other ops.
    prog = Program(ops=[op1, op2], inputs=[t_in1, t_in2], initializers={})
    config = SimConfig(model="test", sim_level="CA_HYBRID", tc=1, vc=1, dma_channels=1)

    schedule, stats = event_driven_schedule(prog, config)

    op2_item = next(item for item in schedule if item.op.name == "op2")

    # op2 should have a dependency stall waiting for op1
    assert op2_item.stall_cycles > 0
    assert "DEP" in op2_item.stall_breakdown
    assert op2_item.stall_breakdown["DEP"] > 0

def test_scheduler_stall_reason_resource():
    """Tests that resource stalls (engine) are correctly identified."""
    # Two independent ops that will compete for the same engine
    t_in1 = Tensor("t_in1", (1,1), "float16", address=0)
    t_in2 = Tensor("t_in2", (1,1), "float16", address=100)
    t_out1 = Tensor("t_out1", (1,1), "float16", address=200)
    
    t_in3 = Tensor("t_in3", (1,1), "float16", address=300)
    t_in4 = Tensor("t_in4", (1,1), "float16", address=400)
    t_out2 = Tensor("t_out2", (1,1), "float16", address=500)

    op1 = NPUOp("MatMul", "op1", inputs=[t_in1, t_in2], outputs=[t_out1])
    op2 = NPUOp("MatMul", "op2", inputs=[t_in3, t_in4], outputs=[t_out2])
    # All 4 input tensors are primary inputs
    prog = Program(ops=[op1, op2], inputs=[t_in1, t_in2, t_in3, t_in4], initializers={})
    # Only one TC engine
    config = SimConfig(model="test", sim_level="CA_HYBRID", tc=1, vc=1, dma_channels=1)

    schedule, stats = event_driven_schedule(prog, config)

    # Find the second matmul to run
    op_starts = sorted([(item.start_cycle, item.op.name) for item in schedule if item.op.opcode == 'MatMul'])
    assert len(op_starts) == 2
    second_op_name = op_starts[1][1]
    second_op_item = next(item for item in schedule if item.op.name == second_op_name)

    # The second op should have a resource stall waiting for the first to finish
    assert second_op_item.stall_cycles > 0
    assert "RESOURCE_ENGINE" in second_op_item.stall_breakdown
    assert second_op_item.stall_breakdown["RESOURCE_ENGINE"] > 0